<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>通过 Hexo 和 Travis 构建一个属于自己的博客</title>
    <url>/2021/06/11/20210607/</url>
    <content><![CDATA[<p>　　<strong>最近开启了大前端学习的道路，从事前端行业两年多了，想要一个自己的 Blog，不管是学习记录还是生活记录，都可以使用起来，而不是繁杂难选的三方平台，乘着学习过程中看到过的 Hexo＋Travis 的方式搭建自己的博客，我也兴致勃勃的想试试，此时你看到的就是搭建结果，这也是第一篇博客！</strong>  </p>
<h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>　　流浪在大前端的今天怎么能没有 node 呢，node 是必备的，大家自行安装即可=。=；  </p>
<span id="more"></span>
<p>　　在自己的 git 仓库新建一个 xxx.github.io 仓库名的仓库，注意此处的 xxx 为你的 git 账号名，我的就是 seachan0117,细心的你可能已经发现，就是浏览器域名中的前一部分，我新建的仓库就是 SeaChan0117.github.io；<br>此时通过浏览器尝试访问 seachan0117.github.io，页面报404，原因是我们项目还是空的，将代码clone到本地，新建一个 index.html，其中可简单填写部分内容测试，提交至远程仓库后，再次访问 seachan0117.github.io，我们的页面就能访问了。<br>其实到这我们的 Blog 就算基本搭建完成，自己可以项目中开发自己的 Blog，但是单纯手工以代码形式去编写 Blog 似乎太累了，也不利于维护，这时就需要用到 Hexo；<br><em>到这我就想，如果是其他项目的编译文件，是静态页面的情况下，如果放到该目录应该也是OK的，当然会涉及一些路径的问题，不过思路到这后续就可以尝试啦。</em>  </p>
<h1 id="Hexo-是什么？"><a href="#Hexo-是什么？" class="headerlink" title="Hexo 是什么？"></a>Hexo 是什么？</h1><p>　　<strong>A fast, simple &amp; powerful blog framework</strong>，官方简洁明了的对 hexo 做了说明。<br>Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页；Hexo 提供了脚手架，帮助我们快速开始属于自己的 Blog 开发；  </p>
<h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>此处全局安装 hexo-cli；<br><code> yarn add globle hexo-cli</code><br>或者<br><code>npm install -g hexo-cli</code></p>
<h2 id="Hexo-初始化"><a href="#Hexo-初始化" class="headerlink" title="Hexo 初始化"></a>Hexo 初始化</h2><p>安装成功后，执行 hexo，命令行会提示相关操作选项，我们此时来初始化 Hexo 开发项目 <strong>hexo init SeaChan0117.github.io</strong>，会在 SeaChan0117.github.io 目录下为我们生成一份初始化的 Hexo 开发项目，后续在其基础上使用 Markdown 语法开发我们的 Blog 即可；<br><code>hexo init SeaChan0117.github.io</code>  </p>
<p>初始化完成后，启动项目，Hexo 默认 <a href="http://localhost:4000/">http://localhost:4000</a> ，打开网址即可查看本地启动的 Hexo 项目；<br><code>yarn server</code><br>或者<br><code>npm run server</code><br>或者<br><code>hexo s</code><br>此时，Hexo 初始化项目就跑起来了，浏览器打开 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到 Hexo 博客，是不是很简单呢。 根据界面上展示的内容在代码中查找，能知道页面的 .md 文档路径是 source\_posts\下，尝试修改后，刷新界面验证自己的想法吧。  </p>
<p>我们可以使用 Hexo 为我们提供的命令生成新页面，放在 source\_posts\ 下：<br><code>hexo new first-blog</code><br>执行上述命令后会新增 first-blog.md 的文件，并初始化了标题和日期  </p>
<p>那么问题来了，我们之前说了把项目名配置为 seachan0117.github.io，就是为了使用 github pages 功能，能浏览器直接访问 seachan0117.github.io 静态页面，怎么把 Hexo 项目在 seachan0117.github.io 访问呢？Hexo 官方为我们提供了一个解决方案 <strong>Travis CI</strong>。</p>
<h1 id="Travis-CI-将-Hexo-部署-GitHub-Pages"><a href="#Travis-CI-将-Hexo-部署-GitHub-Pages" class="headerlink" title="Travis CI 将 Hexo 部署 GitHub Pages"></a>Travis CI 将 Hexo 部署 GitHub Pages</h1><p>　　<a href="https://www.travis-ci.org/">Travis CI</a> 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。  </p>
<h2 id="Travis-CI-使用准备"><a href="#Travis-CI-使用准备" class="headerlink" title="Travis CI 使用准备"></a>Travis CI 使用准备</h2><blockquote>
<p>绑定 github 账号；<br>github 账号下有项目；<br>项目中有可运行代码；<br>该项目还包含有构建或者测试脚本；  </p>
</blockquote>
<p>如果以上条件都满足，你就可以开始使用 Travis CI 了。</p>
<h2 id="Travis-CI-使用流程"><a href="#Travis-CI-使用流程" class="headerlink" title="Travis CI 使用流程"></a>Travis CI 使用流程</h2><p>github 账号绑定登录后，进行授权， Travis CI 会列出你在 github 上的项目列表；<br>在 github 的设置里 <a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>，生成一个 Token，此处我的 Token 名是 <strong>TOKEN</strong>，下面的选项只勾选 repo，点击按钮生成 Token；<br>复制 Token 值，以备后续使用；<br>Travis CI 中选中左侧栏对应的项目仓库，此处我是  SeaChan0117 / SeaChan0117.github.io，右边点击 More options 中的 settings；<br>在 settings 中的 Environment Variables 项填入我们上边复制的 Token，注意 Name 和 Value 对应，然后点击行后的 Add 按钮即可；<br>在本地项目 SeaChan0117.github.io 根目录下新建一个名为<code>.travis.yml</code>的文件，将以下内容复制进去，注意 github-token 项是你自己在 github 上生成的 Token 键名;</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">12</span> <span class="comment"># use nodejs v12 LTS</span></span><br><span class="line"><span class="attr">cache:</span> <span class="string">npm</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># build master branch only</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span> <span class="comment"># clean static files</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>
<p>将 .travis.yml 文件提交至远程仓库，此时 Travis CI 上就会自动开启一个黑盒为启动部署，它会将生成的文件推送到同一 repository 下的 gh-pages 分支下；<br>当查看部署状态为 passed 后，回到 github 上，对应仓库的 settings 下，左侧栏选择 Pages，右边 Source 选择 gh-pages；<br>稍等片刻，再次浏览器中访问 <a href="https://seachan0117.github.io/">SeaChan0117.github.io</a>；<br>Bingo！！！</p>
<h2 id="手动部署"><a href="#手动部署" class="headerlink" title="手动部署"></a>手动部署</h2><p>Hexo 提供了快速方便的一键部署功能，你只需一条命令就能将网站部署到服务器上；<br><code>hexo deploy</code><br>在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br></pre></td></tr></table></figure>
<p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer；   </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">heroku</span></span><br><span class="line">  <span class="attr">repo:</span></span><br></pre></td></tr></table></figure>
<p>知道该配置项后，你还需要安装相关支持的依赖 <strong>hexo-deployer-git</strong>；<br><code>yarn add hexo-deployer-git</code><br>然后修改自己的配置文件，我的配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/SeaChan0117/SeaChan0117.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">&quot;Sea Chan&#x27;s blogs-deploy&quot;</span></span><br></pre></td></tr></table></figure>
<p>分别执行 <code>hexo clean</code> 和 <code>hexo deploy</code>，生成站点文件并推送到远程仓库，此时，再访问 seachan0117.github.io 即可，我们的 Blog 已经部署到服务上！<br>接下来就可以开始书写自己的 Blog，那么问题又来了，每次编写 Blog 或其他文件后，都需要手动发布到服务上。</p>
<h1 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h1><p>现在你看到的是 Hexo 加上 theme-next 呈现的效果，比单纯的 Hexo 美化了很多，后序有时间再整理 theme-next 吧。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 学习笔记</title>
    <url>/2021/06/10/typescript/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/1.jpg" alt="TypeScript"></p>
<span id="more"></span>
<p>TypeScript（本文后续统一使用TS），是一门解决JavaScript自有类型系统问题的语音（提高代码可靠程度）。它是JavaScript类型的超集，可以编译出纯净、 简洁的JavaScript代码，并且可以运行在任何浏览器上、Node.js环境中和任何支持ECMAScript 3（或更高版本）的JavaScript引擎中。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul>
<li>强类型与弱类型</li>
<li>静态类型与动态类型</li>
<li>JavaScript自有系统类型问题</li>
</ul>
<h1 id="强类型与弱类型-类型安全"><a href="#强类型与弱类型-类型安全" class="headerlink" title="强类型与弱类型(类型安全)"></a>强类型与弱类型(类型安全)</h1><p>强类型：在语言层面就限制了函数的实参类型必须与形参类型相同；<br>弱类型：语言层面不会显示实参的类型；  </p>
<p>强类型有更强的类型约束，而弱类型中几乎没有约束，强类型语言中不允许任意的隐式类型转换，而弱类型语言则允许任意的数据隐式类型转换。  </p>
<p>JavaScript就是典型的弱类型语言。JavaScript中所有错误都是在代码执行层面，通过逻辑判断手动抛出的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;100&#x27;</span> - <span class="number">50</span> <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.flor(<span class="literal">true</span>)   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="静态类型与动态类型-类型检查"><a href="#静态类型与动态类型-类型检查" class="headerlink" title="静态类型与动态类型(类型检查)"></a>静态类型与动态类型(类型检查)</h1><p>静态类型：一个变量在声明时它的类型就是明确的，声明过后，它的类型就不可修改；<br>动态类型：在代码运行阶段才能明确变量的类型，而且变量的类型随时可以改变；  </p>
<p>可以说动态类型语言中的变量没有类型，变量中存放的值是有类型的，静态类型和动态类型的区别就是，是否允许随时修改变量的类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript动态语言示例</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>以下是一些语言的划分，可以看出强类型不等于静态类型，弱类型不等于动态类型。<br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/2.jpg" alt="语言类型划分"></p>
<h1 id="JavaScript自有系统类型问题"><a href="#JavaScript自有系统类型问题" class="headerlink" title="JavaScript自有系统类型问题"></a>JavaScript自有系统类型问题</h1><p>JavaScript是一门标准的弱类型且动态类型的语音，所以JS灵活多变，所以JS缺失类型系统的可靠性。</p>
<p>弱类型问题示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js在执行时才检测错误</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj.foo()    <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    obj.foo()    <span class="comment">// 报错</span></span><br><span class="line">&#125;, <span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型不确定导致，代码执行结果不是预期，函数功能发生改变，就需要添加约定去限制入参，然而约定没有保障，不能保证每个开发都会做</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b  <span class="comment">// 期望做两个数值相加的结果</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">sum(<span class="string">&#x27;100&#x27;</span>, <span class="number">100</span>)   <span class="comment">// &quot;100100&quot;  结果为字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据定义时没有类型要求，导致定义和预期产生偏差，对象索引器的错误用法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj[<span class="literal">true</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;true&#x27;</span>])  <span class="comment">// 1   true作为属性时，被自动转为了字符串</span></span><br></pre></td></tr></table></figure>

<p>相较于弱类型语音，强类型有着明显的优势：</p>
<ul>
<li>错误更早暴露（编码阶段就能发现并避免类型异常）；</li>
<li>代码更智能，编码更准确（开发工具智能提示能更准确的语法，大大提高编码效率）；</li>
<li>重构更牢靠（重构时，能及时暴露出相关代码异常信息，可及时准确的对耦合代码进行修改）；</li>
<li>减少不必要的类型判断（在编码阶段，参数类型已经确定，就不用再对类型做约定判断）；</li>
</ul>
<p><strong>flow：JavaScript类型检查器工具</strong>  </p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://flow.org">Flow: A Static Type Checker for JavaScript</a></li>
<li><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844903599173173255">用Flow提升前端健壮性</a></li>
<li><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6900912350640275470">Flow（一）– JavaScript静态类型检查器</a></li>
<li><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6900927463296073736">Flow（二）– 简单语法使用</a></li>
</ul>
<p><strong>TS语言规范与基本运用</strong><br>TS功能强大，生态健全完善，工具支持度高。<br>缺点：</p>
<ul>
<li>相较于JavaScript多了很多概念，提高了学习成本；</li>
<li>小项目或项目初期，TS会增加成本（要编写很多的类型声明）<h2 id="TS-快速上手（nmp为例）"><a href="#TS-快速上手（nmp为例）" class="headerlink" title="TS 快速上手（nmp为例）"></a>TS 快速上手（nmp为例）</h2>在工程目录（TS为例）下执行 npm init -y 初始化项目管理的 package.json 文件；</li>
</ul>
<p>执行 npm install typescript –save –dev 安装TS到开发依赖，此时node_modules目录下会多出.bin文件夹，目录下的tsc命令用于后续编译TS代码；<br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/3.jpg" alt="图3"></p>
<p>在TS根目录下新建第一个TS文件，01-getting-started.ts ，执行命令npx tsc 01-getting-started.ts 将TS文件编译为JS文件：<br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/4.jpg" alt="图4"><br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/5.jpg" alt="图5"><br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/6.jpg" alt="图6"></p>
<p>TS强类型体现：<br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/7.jpg" alt="图7"><br>![图8](<a href="https://raw.gitts文件,也可以编译整个项目或工程,在编译整个项目之前,需要创建一个ts的配置文件,通过命令初始化生成该配置文件/">https://raw.gitTS文件，也可以编译整个项目或工程，在编译整个项目之前，需要创建一个TS的配置文件，通过命令初始化生成该配置文件</a> npx tsc –init ，在项目根目录下生成一个 tsconfig.json 的配置文件。<br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/9.jpg" alt="图9"><br>tsconfig.json详细配置项详情参考以下链接：  </p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904054770892813">tsconfig.json入门指南</a></li>
<li><a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904178234458120">掌握 tsconfig.json</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">Documentation - What is a tsconfig.json</a></li>
<li>[jsconfig.json Refehubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/8.jpg)<pre><code>               ## TS 配置文件
               tsc命令不单可以编译单个rence](https://link.zhihu.com/?target=https%3A//code.visualstudio.com/docs/languages/jsconfig)
</code></pre>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="comment">// &quot;incremental&quot;: true,                         /* Enable incremental compilation */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2015&quot;</span>,                                <span class="comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,                           <span class="comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;lib&quot;: [],                                   /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;allowJs&quot;: true,                             /* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="comment">// &quot;checkJs&quot;: true,                             /* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// &quot;jsx&quot;: &quot;preserve&quot;,                           /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, &#x27;react&#x27;, &#x27;react-jsx&#x27; or &#x27;react-jsxdev&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;declaration&quot;: true,                         /* Generates corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;declarationMap&quot;: true,                      /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">     <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,                           <span class="comment">/* Generates corresponding &#x27;.map&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;outFile&quot;: &quot;./&quot;,                             /* Concatenate and emit output to single file. */</span></span><br><span class="line">     <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>,                              <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">     <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;src&quot;</span>,                             <span class="comment">/* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// &quot;composite&quot;: true,                           /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// &quot;tsBuildInfoFile&quot;: &quot;./&quot;,                     /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="comment">// &quot;removeComments&quot;: true,                      /* Do not emit comments to output. */</span></span><br><span class="line">    <span class="comment">// &quot;noEmit&quot;: true,                              /* Do not emit outputs. */</span></span><br><span class="line">    <span class="comment">// &quot;importHelpers&quot;: true,                       /* Import emit helpers from &#x27;tslib&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;downlevelIteration&quot;: true,                  /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;isolatedModules&quot;: true,                     /* Transpile each file as a separate module (similar to &#x27;ts.transpileModule&#x27;). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,                                 <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitAny&quot;: true,                       /* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;strictNullChecks&quot;: true,                    /* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// &quot;strictFunctionTypes&quot;: true,                 /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// &quot;strictBindCallApply&quot;: true,                 /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span></span><br><span class="line">    <span class="comment">// &quot;strictPropertyInitialization&quot;: true,        /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitThis&quot;: true,                      /* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;alwaysStrict&quot;: true,                        /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedLocals&quot;: true,                      /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedParameters&quot;: true,                  /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitReturns&quot;: true,                   /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// &quot;noFallthroughCasesInSwitch&quot;: true,          /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line">    <span class="comment">// &quot;noUncheckedIndexedAccess&quot;: true,            /* Include &#x27;undefined&#x27; in index signature results */</span></span><br><span class="line">    <span class="comment">// &quot;noPropertyAccessFromIndexSignature&quot;: true,  /* Require undeclared properties from index signatures to use element accesses. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// &quot;moduleResolution&quot;: &quot;node&quot;,                  /* Specify module resolution strategy: &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// &quot;baseUrl&quot;: &quot;./&quot;,                             /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// &quot;paths&quot;: &#123;&#125;,                                 /* A series of entries which re-map imports to lookup locations relative to the &#x27;baseUrl&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDirs&quot;: [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// &quot;typeRoots&quot;: [],                             /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// &quot;types&quot;: [],                                 /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;allowSyntheticDefaultImports&quot;: true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,                        <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;preserveSymlinks&quot;: true,                    /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// &quot;allowUmdGlobalAccess&quot;: true,                /* Allow accessing UMD globals from modules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// &quot;sourceRoot&quot;: &quot;&quot;,                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// &quot;mapRoot&quot;: &quot;&quot;,                               /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSourceMap&quot;: true,                     /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSources&quot;: true,                       /* Emit the source alongside the sourcemaps within a single file; requires &#x27;--inlineSourceMap&#x27; or &#x27;--sourceMap&#x27; to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// &quot;experimentalDecorators&quot;: true,              /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// &quot;emitDecoratorMetadata&quot;: true,               /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>,                           <span class="comment">/* Skip type checking of declaration files. */</span></span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>        <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
配置文件初始化并配置想过配置项后，运行 npx tsc 就可编译整个项目：<br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/10.jpg" alt="图10">  </li>
</ul>
<h2 id="TS-原始类型"><a href="#TS-原始类型" class="headerlink" title="TS 原始类型"></a>TS 原始类型</h2><p>TypeScript的原始类型包括: boolean、number、string、void、undefined、null、symbol、bigint，在声明变量时都应该加上类型约束。<br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/11.jpg" alt="图11"></p>
<h2 id="TS-作用域问题"><a href="#TS-作用域问题" class="headerlink" title="TS 作用域问题"></a>TS 作用域问题</h2><p>以上 02-primitive.ts 文件中定义了 a 变量，此时在 03-module-scope.ts 中再次声明一个 a 变量，代码提示报错，变量名重复。<br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/12.jpg" alt="图12"><br><img src="https://raw.githubusercontent.com/SeaChan0117/SeaChan0117.github.io/master/source/_posts/typescript/13.jpg" alt="图13">  </p>
<h2 id="TS-Object类型（所有非原始类型，对象、数组、函数等）"><a href="#TS-Object类型（所有非原始类型，对象、数组、函数等）" class="headerlink" title="TS Object类型（所有非原始类型，对象、数组、函数等）"></a>TS Object类型（所有非原始类型，对象、数组、函数等）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object类型，function, [], &#123;&#125;</span></span><br><span class="line"><span class="comment">// const foo: object = function () &#123;&#125; // []  // &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义单纯&#123;&#125;字面量对象</span></span><br><span class="line"><span class="keyword">const</span> foo: &#123;&#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> bar: &#123;<span class="attr">a</span>: string, <span class="attr">b</span>: number&#125; = &#123;<span class="attr">a</span>: <span class="string">&#x27;123&#x27;</span>, <span class="attr">b</span>: <span class="number">123</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TS-数组类型"><a href="#TS-数组类型" class="headerlink" title="TS 数组类型"></a>TS 数组类型</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array泛型</span></span><br><span class="line"><span class="keyword">const</span> arr: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// [type][] 方式</span></span><br><span class="line"><span class="keyword">const</span> arr1: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// =========================</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args: number[]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 入参无强类型约束时，此处需对数组每个值做判断</span></span><br><span class="line">    args.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TS-元组类型"><a href="#TS-元组类型" class="headerlink" title="TS 元组类型"></a>TS 元组类型</h2><p><strong>元组类型</strong>：元组可以当做是数组的拓展，它表示已知元素数量和类型的数组。确切地说，是已知数组中每一个位置上的元素的类型。明确元素数量及每个元素类型，元素的类型不必完全相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tuple: [number,string] = [<span class="number">17</span>, <span class="string">&#x27;SeaChan&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// const age = tuple[0]</span></span><br><span class="line"><span class="comment">// const name = tuple[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [age, name] = tuple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====================</span></span><br><span class="line"><span class="comment">// Object.entries 就返回元组数据</span></span><br><span class="line"><span class="built_in">Object</span>.entries(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&#x27;456&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="TS-枚举类型"><a href="#TS-枚举类型" class="headerlink" title="TS 枚举类型"></a>TS 枚举类型</h2><p>export {}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举： 给一组值定义更好理解的名字；一个枚举中只会存在一组固定的值，不会出现超出范围的可能性；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enum PostStatus &#123;</span><br><span class="line">    Draft = <span class="number">0</span>,</span><br><span class="line">    Unpublished = <span class="number">1</span>,</span><br><span class="line">    Published = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> post = &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Hello TypeScript&#x27;</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;TypeScript is a typed superset of JavaScript&#x27;</span>,</span><br><span class="line">    <span class="attr">status</span>: PostStatus.Draft  <span class="comment">// 0 草稿，1 未发布，2 已发布；这几个状态值就可以用枚举来处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TS-函数类型"><a href="#TS-函数类型" class="headerlink" title="TS 函数类型"></a>TS 函数类型</h2><p>默认情况下，枚举是基于 0 的，也就是说第一个值是 0，后面的值依次递增。不要担心，当中的每一个值都可以显式指定，只要不出现重复即可，没有被显式指定的值，都会在前一个值的基础上递增，如果是字符串就需要所有显示指定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明类型限制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a: number, b: number = <span class="number">10</span>, ...rest: number[]</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式类型限制=======&gt; 对f2做类型限制使用箭头函数</span></span><br><span class="line"><span class="keyword">const</span> f2: <span class="function">(<span class="params">a: number, b: number, ...rest: number[]</span>) =&gt;</span> string = <span class="function"><span class="keyword">function</span> (<span class="params">a: number, b: number, ...rest: number[]</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="TS-任意类型（any和unknown）"><a href="#TS-任意类型（any和unknown）" class="headerlink" title="TS 任意类型（any和unknown）"></a>TS 任意类型（any和unknown）</h2><p>any 和 unknown 的最大区别是, unknown 是 top type (任何类型都是它的 subtype) , 而 any 即是 top type, 又是 bottom type (它是任何类型的 subtype ) , 这导致 any 基本上就是放弃了任何类型检查。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">val: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stringify(<span class="number">100</span>)</span><br><span class="line">stringify(<span class="string">&#x27;100&#x27;</span>)</span><br><span class="line">stringify(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// any 相当于回归JavaScript,动态类型，此时TS对相应的代码不再做类型检查；所以尽量不要使用any</span></span><br><span class="line"><span class="keyword">let</span> foo: any = <span class="number">100</span></span><br><span class="line">foo = <span class="string">&#x27;string&#x27;</span></span><br><span class="line">foo.fn()</span><br></pre></td></tr></table></figure>

<h2 id="TS-类型断言"><a href="#TS-类型断言" class="headerlink" title="TS 类型断言"></a>TS 类型断言</h2><p>类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构, 它没有运行时的影响，只是在编译阶段起作用，TS会假设编码人员已经检查过数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> res = arr.find(<span class="function"><span class="params">i</span> =&gt;</span> i &gt; <span class="number">0</span>) <span class="comment">// res 被断言为 number | undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const mul = res * res   // 此时res计算会报错，因为ts断言存在undefined情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们需要告诉ts，res不会是undefined</span></span><br><span class="line"><span class="keyword">const</span> num = res <span class="keyword">as</span> number       <span class="comment">// as 断言    推荐使用</span></span><br><span class="line"><span class="keyword">const</span> num1 = &lt;number&gt;res        <span class="comment">// &lt; [type] &gt; 断言; JSX下会有语法冲突，不能使用这种</span></span><br><span class="line"><span class="keyword">const</span> mul = num * num           <span class="comment">// 告诉ts，res一定是数字类型时，不再报错</span></span><br><span class="line"><span class="keyword">const</span> mul1 = num1 * num1</span><br></pre></td></tr></table></figure>

<h2 id="TS-接口"><a href="#TS-接口" class="headerlink" title="TS 接口"></a>TS 接口</h2><p>作为用过Java的猿来说，接口在面向对象的语言中，是一个很重要的概念，它是对一类行为的抽象，具体行为如何，需要具体的类去实现它们。<br>TS中的接口可以是针对对象的，约定一个对象中有哪些成员，且这些成员是什么样的；也可以是上边说的行为抽象，下边会讲到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">interface Person &#123;</span><br><span class="line">    readonly name: string   <span class="comment">// readonly 只读属性</span></span><br><span class="line">    firsName?: string       <span class="comment">// ？ 可选属性</span></span><br><span class="line">    <span class="attr">age</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPerson</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(person.name);</span><br><span class="line">    <span class="built_in">console</span>.log(person.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showPerson(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;SeaChan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">17</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">interface Cache &#123;</span><br><span class="line">    [key: string]: string       <span class="comment">// 动态属性，当前为string类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache: Cache = &#123;&#125;</span><br><span class="line">cache.foo = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">cache.var = <span class="string">&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="TS-类的基本使用"><a href="#TS-类的基本使用" class="headerlink" title="TS 类的基本使用"></a>TS 类的基本使用</h2><p><strong>class</strong>, 描述一类具体事物的抽象特征。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public name: string  <span class="comment">// = &#x27;init name&#x27; 必须在此或者构造函数中初始化</span></span><br><span class="line">    protected readonly age: number  <span class="comment">// readonly 只读</span></span><br><span class="line">    private gender: boolean = <span class="literal">true</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: string, age: number</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello(msg: string):<span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hello, i am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, and i am a <span class="subst">$&#123;<span class="built_in">this</span>.gender ? <span class="string">&#x27;boy&#x27;</span>: <span class="string">&#x27;girl&#x27;</span>&#125;</span>, <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问修饰符 private私有的，只能在当前内部使用；protected受保护的，能在当前内部和子类里边访问到；public公有的，能在实例对象上访问到</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;SeaChan&#x27;</span>, <span class="number">17</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name);       <span class="comment">// SeaChan</span></span><br><span class="line"><span class="comment">// console.log(p1.age);        // 报错</span></span><br><span class="line"><span class="comment">// console.log(p1.gender);     // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承Person后protected可访问到</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kids</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: string, age: number</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHi(msg: string):<span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="string">`Hi, i am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old, <span class="subst">$&#123;msg&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> k1 = <span class="keyword">new</span> Kids(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>)</span><br><span class="line">k1.sayHello(<span class="string">&#x27;hahaha&#x27;</span>)                   <span class="comment">// Hi, i am 12 years old, hahaha</span></span><br></pre></td></tr></table></figure>

<h2 id="TS-接口和类"><a href="#TS-接口和类" class="headerlink" title="TS 接口和类"></a>TS 接口和类</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 接口和类</span></span><br><span class="line"><span class="comment">// 把一些类之间共通的属性或者特征定位为接口，各个类再去实现响应的接口</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">EatAndRun</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: string</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: string</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params">food: string</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`run with 2 feet`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animals</span> <span class="title">implements</span> <span class="title">EatAndRun</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: string</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: string</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params">food: string</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`run with 4 feet`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person和Animals中都有eat和run两个方法，他们可抽象为接口，用于约束两个类的行为，在两个类中就得实现接口中的方法</span></span><br><span class="line">interface EatAndRun &#123;</span><br><span class="line">    eat(food: string): <span class="keyword">void</span></span><br><span class="line">    run(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TS-抽象类"><a href="#TS-抽象类" class="headerlink" title="TS 抽象类"></a>TS 抽象类</h2><p><strong>多态</strong>：父类定义一个方法不去实现，让继承它的子类去实现 每一个子类有不同的表现，使用多态基础是类的继承或者接口实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 抽象类, 只能继承，不能使用 new 去创建对象</span></span><br><span class="line"><span class="comment">// 适用于比较大的概念或者类目，如 Animals</span></span><br><span class="line"></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    eat(food: string): <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract run(distance: number): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public name: string</span><br><span class="line">    public age: number</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: string, age: number</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run(distance: number): <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    public age: number;</span><br><span class="line">    private readonly gender: boolean;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: string, age: number, gender: boolean</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">        <span class="built_in">this</span>.gender = gender</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run(distance: number): <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">d.run(<span class="number">200</span>)          <span class="comment">// 200</span></span><br><span class="line">d.eat(<span class="string">&#x27;Meat&#x27;</span>)           <span class="comment">// Meat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;SeaChan&#x27;</span>, <span class="number">17</span>, <span class="literal">true</span>)</span><br><span class="line">p.eat(<span class="string">&#x27;KFC&#x27;</span>)            <span class="comment">// KFC</span></span><br><span class="line">p.run(<span class="number">10</span>)             <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="TS-泛型"><a href="#TS-泛型" class="headerlink" title="TS 泛型"></a>TS 泛型</h2><p>在定义接口或函数时，没有定义具体的类型，使用的时候再定义具体类型，能极大程度的复用代码，减少冗余代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 泛型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">length: number, val: T</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>&lt;T&gt;(length).fill(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(<span class="number">3</span>, <span class="number">100</span>)         <span class="comment">// [100, 100, 100]</span></span><br><span class="line">createArray(<span class="number">3</span>, <span class="string">&#x27;string&#x27;</span>)    <span class="comment">// [&#x27;string&#x27;, &#x27;string&#x27;, &#x27;string&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="TS-类型声明"><a href="#TS-类型声明" class="headerlink" title="TS 类型声明"></a>TS 类型声明</h2><p>当使用一些第三个插件或库时，它们不一定是使用TS编写的，就不具有强类型的数据声明，此时可以通过declare进行自定义声明，或者安装相关类型声明模块到开发依赖，如lodash，可以安装@types/lodash。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本人于19-20年用过半年的Angular7，但是项目团队中没有系统的TS指导，基本都是在使用一些简单的api，各种CV搞业务，基本没有技术沉淀，只算是接触了一点，现在借着大前端发展的浪头，开始一系列的学习之旅，本文是一些简单的TS学习笔记，更多的需要在实战中去理解和掌握，大前端，冲！！！console.log(‘加油ヾ(◍°∇°◍)ﾉﾞ’)！</p>
]]></content>
      <categories>
        <category>TypeScript</category>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ES新特性</title>
    <url>/2021/06/10/20210610205248/</url>
    <content><![CDATA[<h1 id="ECMAScript（ES）："><a href="#ECMAScript（ES）：" class="headerlink" title="ECMAScript（ES）："></a>ECMAScript（ES）：</h1><p>也是脚本语言，通常被看成是JavaScript的标准化规范，实际上JavaScript是ES的扩展语言，ES提供了基本的语法，比如怎么去定义变量，怎么进行条件判断等。JavaScript则实现了这些语法，并做了相应的扩展，比如在浏览器环境中操作BOM/DOM，在node环境中操作文件等操作。</p>
<p>浏览器环境：JavaScript = ES + Web APIs（BOM+DOM）</p>
<p>node环境：JavaScript = ES + Node APIs（fs + net + etc.）</p>
<blockquote>
<p>ECMAScript和JavaScript的关系：<br>1996年11月，JavaScript的创造者–Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这门语言能够成为国际标准。<br>次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。该标准一开始就是针对JavaScript语言制定的，但是没有称其为JavaScript，<br>有两个方面的原因。<br>一是商标，JavaScript本身已被Netscape注册为商标。<br>二是想体现这门语言的制定者是ECMA，而不是Netscape，这样有利于保证这门语言的开发性和中立性。</p>
</blockquote>
<span id="more"></span>

<h1 id="ECMAScript2015（ES2015-ES6）："><a href="#ECMAScript2015（ES2015-ES6）：" class="headerlink" title="ECMAScript2015（ES2015/ES6）："></a>ECMAScript2015（ES2015/ES6）：</h1><h2 id="1-较之前版本的变化"><a href="#1-较之前版本的变化" class="headerlink" title="1.较之前版本的变化"></a>1.较之前版本的变化</h2><ul>
<li>解决原有语法上的问题或不足（let，const提供的块级作用域）；</li>
<li>对原有语法进行增强（解构展开，模板字符串等）；</li>
<li>全新的对象，全新的方法，全新的功能（Promise，proxy等）；</li>
<li>全新的数据类型和数据结构（Symbol，Set，Map）；</li>
</ul>
<h2 id="2-let-const与块级作用域"><a href="#2-let-const与块级作用域" class="headerlink" title="2.let/const与块级作用域"></a>2.let/const与块级作用域</h2><p>作用域，即某个成员起作用的范围。在全局作用域和函数作用域的基础之上，ES2015又新增了块级作用域。</p>
<p>块，就是代码中一对花括号内的范围，如if语句和for循环语句中的花括号都是块，在没有块级作用域之前，在块里边定义的变量（使用var声明的变量），在外边也能访问到。使用let/const声明的变量在块外边是无法访问到的。</p>
<p>const在let基础上多了一个只读的特性，即变量一旦声明就不可改变（指向内存地址不可改变），所以const声明变量时必须赋值。</p>
<p>如果声明的变量是一个引用，引用中的属性改变不会改变变量的指向地址，是有效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj.name = <span class="string">&#x27;lagou&#x27;</span>  <span class="comment">// 未改变obj指向地址，有效</span></span><br><span class="line">obj = &#123;&#125;   <span class="comment">// 重新赋值，修改了obj的指向地址，报错</span></span><br></pre></td></tr></table></figure>
<p><strong>最佳实践：不用var，主用const，配合let</strong></p>
<h2 id="3-数组和对象的解构"><a href="#3-数组和对象的解构" class="headerlink" title="3.数组和对象的解构"></a>3.数组和对象的解构</h2><p>解构赋值是对赋值运算符的扩展。它是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// a = 1// b = 2// c = 3</span></span><br></pre></td></tr></table></figure>
<h4 id="可嵌套"><a href="#可嵌套" class="headerlink" title="可嵌套"></a>可嵌套</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure>

<h4 id="可忽略"><a href="#可忽略" class="headerlink" title="可忽略"></a>可忽略</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure>

<h4 id="不完全解构"><a href="#不完全解构" class="headerlink" title="不完全解构"></a>不完全解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="剩余运算符"><a href="#剩余运算符" class="headerlink" title="剩余运算符"></a>剩余运算符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// a = &#x27;h&#x27;</span></span><br><span class="line"><span class="comment">// b = &#x27;e&#x27;</span></span><br><span class="line"><span class="comment">// c = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// d = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// e = &#x27;o&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="解构默认值"><a href="#解构默认值" class="headerlink" title="解构默认值"></a>解构默认值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><h4 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;aaa&#x27;</span></span><br><span class="line"><span class="comment">// bar = &#x27;bbb&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">baz</span> : foo &#125; = &#123; <span class="attr">baz</span> : <span class="string">&#x27;ddd&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;ddd&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="可嵌套可忽略"><a href="#可嵌套可忽略" class="headerlink" title="可嵌套可忽略"></a>可嵌套可忽略</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="不完全解构-1"><a href="#不完全解构-1" class="headerlink" title="不完全解构"></a>不完全解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="剩余运算符-1"><a href="#剩余运算符-1" class="headerlink" title="剩余运算符"></a>剩余运算符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="解构默认值-1"><a href="#解构默认值-1" class="headerlink" title="解构默认值"></a>解构默认值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-模板字符串"><a href="#4-模板字符串" class="headerlink" title="4.模板字符串"></a>4.模板字符串</h2><p>模板字符串相当于加强版的字符串，用反引号`,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。（模板字符串中的换行和空格都是会被保留的）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 =  <span class="string">`Hey,</span></span><br><span class="line"><span class="string">can you stop angry now?`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string1);</span><br><span class="line"><span class="comment">// Hey,</span></span><br><span class="line"><span class="comment">// can you stop angry now?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`My Name is <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;age+<span class="number">1</span>&#125;</span> years old next year.`</span></span><br><span class="line"><span class="built_in">console</span>.log(info);</span><br><span class="line"><span class="comment">// My Name is Mike,I am 28 years old next year.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;have fun!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2= <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string2);  <span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure>

<p>标签模板—-是一个函数的调用，其中调用的参数是模板字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`Hello world!`</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">alert(<span class="string">&#x27;Hello world!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-字符串的扩展方法（startsWith，endsWith，includes）"><a href="#5-字符串的扩展方法（startsWith，endsWith，includes）" class="headerlink" title="5.字符串的扩展方法（startsWith，endsWith，includes）"></a>5.字符串的扩展方法（startsWith，endsWith，includes）</h2><h2 id="6-参数默认值"><a href="#6-参数默认值" class="headerlink" title="6.参数默认值"></a>6.参数默认值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// y is 10 if not passed or undefined</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myFunction(<span class="number">0</span>, <span class="number">2</span>) <span class="comment">// 输出 2</span></span><br><span class="line">myFunction(<span class="number">5</span>); <span class="comment">// 输出 15, y 参数的默认值</span></span><br></pre></td></tr></table></figure>
<h2 id="7-剩余参数"><a href="#7-剩余参数" class="headerlink" title="7.剩余参数"></a>7.剩余参数</h2><p>JS函数内部有个arguments对象，可以拿到全部实参，ES6给我们带来了一个新的对象，可以拿到除开始参数外的参数，即剩余参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(rest)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">1</span>) </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, ...rest, b</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错，剩余参数即只能出现在最后</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当您使用剩余参数后，函数的length属性会发生一些变化,即length不包含rest</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">func.length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// rest不能和arguments一起使用，FireFox会报错</span></span><br></pre></td></tr></table></figure>

<p>arguments和剩余参数的区别</p>
<ul>
<li>arguments是一个伪数组（Array-like）</li>
<li>剩余参数是一个真正数组（Array），具有Array.prototype上的所有方法</li>
<li>arguments上有callee，callee上有caller</li>
</ul>
<h2 id="8-数组展开"><a href="#8-数组展开" class="headerlink" title="8.数组展开"></a>8.数组展开</h2><p>其实参照上一条，可以看出“…”符号的作用是将数组展开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr)</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<h2 id="9-箭头函数"><a href="#9-箭头函数" class="headerlink" title="9.箭头函数"></a>9.箭头函数</h2><p>极大地减少代码量，简化代码且更易读；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2</span><br></pre></td></tr></table></figure>

<p>箭头函数内部的this是词法作用域，由上下文确定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">say</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">say_</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.say()</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">person.say_()</span><br><span class="line"><span class="comment">// Tom</span></span><br></pre></td></tr></table></figure>

<h2 id="10-Object-assign"><a href="#10-Object-assign" class="headerlink" title="10.Object.assign"></a>10.Object.assign</h2><p>Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出TypeError错误。</p>
<p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target  =  &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个参数，Object.assign会直接返回该参数。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;  </span><br><span class="line"><span class="built_in">Object</span>.assign(obj) === obj <span class="comment">// true  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果该参数不是对象，则会先转成对象，然后返回。</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// &quot;object&quot;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">//  报错  </span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">//  报错  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.assign只拷贝自身属性，不可枚举的属性（enumerable为false）和继承的属性不会被拷贝。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123; b: &#x27;c&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123;b: &quot;c&quot;, invisible: &quot;hello&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于嵌套的对象，Object.assign的处理方法是替换，而不是添加。</span></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">var</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;  </span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);  </span><br><span class="line">obj1.a.b = <span class="number">2</span>;  </span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>11.Proxy（大部分摘自：<a href="http://blog.poetries.top/2018/12/21/es6-proxy/%EF%BC%89">http://blog.poetries.top/2018/12/21/es6-proxy/）</a><br>proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;poetries&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> logHandler = &#123;</span><br><span class="line">   <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 被读取`</span>);</span><br><span class="line">     <span class="keyword">return</span> target[key];</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 被设置为 <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">     target[key] = value;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> targetWithLog = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, logHandler);</span><br><span class="line"> </span><br><span class="line"> targetWithLog.name; <span class="comment">// 控制台输出：name 被读取</span></span><br><span class="line"> targetWithLog.name = <span class="string">&#x27;others&#x27;</span>; <span class="comment">// 控制台输出：name 被设置为 others</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">console</span>.log(target.name); <span class="comment">// 控制台输出: others</span></span><br></pre></td></tr></table></figure>

<ul>
<li>targetWithLog 读取属性的值时，实际上执行的是 logHandler.get ：在控制台输出信息，并且读取被代理对象 target 的属性。</li>
<li>在 targetWithLog 设置属性值时，实际上执行的是 logHandler.set ：在控制台输出信息，并且设置被代理对象 target 的属性的值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于拦截函数总是返回35，所以访问任何属性都得到35</span></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>Proxy 实例也可以作为其他对象的原型对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。</p>
<p>对于代理模式Proxy的作用主要体现在三个方面：</p>
<p>拦截和监视外部对对象的访问<br>降低函数或类的复杂度<br>在复杂操作前对操作进行校验或对所需资源进行管理<br>Proxy所能代理的范围–handler</p>
<p>实际上handler本身就是ES6所新设计的一个对象.它的作用就是用来 自定义代理对象的各种可代理操作 。它本身一共有13中方法,每种方法都可以代理一种操作.其13种方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span></span><br><span class="line">handler.getPrototypeOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span></span><br><span class="line">handler.setPrototypeOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span></span><br><span class="line">handler.isExtensible()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span></span><br><span class="line">handler.preventExtensions()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。</span></span><br><span class="line">handler.getOwnPropertyDescriptor()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span></span><br><span class="line">handler.defineProperty()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span></span><br><span class="line">handler.has()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span></span><br><span class="line">handler.get()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span></span><br><span class="line">handler.set()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span></span><br><span class="line">handler.deleteProperty()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span></span><br><span class="line">handler.ownKeys()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span></span><br><span class="line">handler.apply()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span></span><br><span class="line">handler.construct()</span><br></pre></td></tr></table></figure>

<h3 id="Proxy场景"><a href="#Proxy场景" class="headerlink" title="Proxy场景"></a>Proxy场景</h3><p>实现私有变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;poetries&#x27;</span>,</span><br><span class="line">   <span class="attr">_age</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logHandler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target,key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key.startsWith(<span class="string">&#x27;_&#x27;</span>))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;私有变量age不能被访问&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(key.startsWith(<span class="string">&#x27;_&#x27;</span>))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;私有变量age不能被修改&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">     target[key] = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> targetWithLog = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, logHandler);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 私有变量age不能被访问</span></span><br><span class="line">targetWithLog.name; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 私有变量age不能被修改</span></span><br><span class="line">targetWithLog.name = <span class="string">&#x27;others&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在下面的代码中，我们声明了一个私有的apiKey，便于api这个对象内部的方法调用，但不希望从外部也能够访问api._apiKey</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> api = &#123;  </span><br><span class="line">    <span class="attr">_apiKey</span>: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    <span class="comment">/* mock methods that use this._apiKey */</span></span><br><span class="line">    <span class="attr">getUsers</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, </span><br><span class="line">    <span class="attr">getUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>)</span>&#123;&#125;, </span><br><span class="line">    <span class="attr">setUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logs &#x27;123abc456def&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;An apiKey we want to keep private&quot;</span>, api._apiKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get and mutate _apiKeys as desired</span></span><br><span class="line"><span class="keyword">var</span> apiKey = api._apiKey;  </span><br><span class="line">api._apiKey = <span class="string">&#x27;987654321&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>很显然，约定俗成是没有束缚力的。使用 ES6 Proxy 我们就可以实现真实的私有变量了，下面针对不同的读取方式演示两个不同的私有化方法。第一种方法是使用 set / get 拦截读写请求并返回 undefined:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;  </span><br><span class="line">    <span class="attr">_apiKey</span>: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    <span class="attr">getUsers</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;, </span><br><span class="line">    <span class="attr">getUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>)</span>&#123; &#125;, </span><br><span class="line">    <span class="attr">setUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>)</span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RESTRICTED = [<span class="string">&#x27;_apiKey&#x27;</span>];</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;  </span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(RESTRICTED.indexOf(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(RESTRICTED.indexOf(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作都会抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(api._apiKey);</span><br><span class="line">api._apiKey = <span class="string">&#x27;987654321&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>第二种方法是使用has拦截in操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> api = &#123;  </span><br><span class="line">    <span class="attr">_apiKey</span>: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    <span class="attr">getUsers</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;, </span><br><span class="line">    <span class="attr">getUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>)</span>&#123; &#125;, </span><br><span class="line">    <span class="attr">setUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>)</span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RESTRICTED = [<span class="string">&#x27;_apiKey&#x27;</span>];</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;  </span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (RESTRICTED.indexOf(key) &gt; -<span class="number">1</span>) ?</span><br><span class="line">            <span class="literal">false</span> :</span><br><span class="line">            <span class="built_in">Reflect</span>.has(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// these log false, and `for in` iterators will ignore _apiKey</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;_apiKey&quot;</span> <span class="keyword">in</span> api);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> api) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (api.hasOwnProperty(key) &amp;&amp; key === <span class="string">&quot;_apiKey&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;This will never be logged because the proxy obscures _apiKey...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽离校验模块</p>
<blockquote>
<p>让我们从一个简单的类型校验开始做起，这个示例演示了如何使用Proxy保障数据类型的准确性</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numericDataStore = &#123;  </span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">amount</span>: <span class="number">1234</span>,</span><br><span class="line">    <span class="attr">total</span>: <span class="number">14</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">numericDataStore = <span class="keyword">new</span> <span class="built_in">Proxy</span>(numericDataStore, &#123;  </span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&quot;Properties in numericDataStore can only be numbers&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误，因为 &quot;foo&quot; 不是数值</span></span><br><span class="line">numericDataStore.count = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值成功</span></span><br><span class="line">numericDataStore.count = <span class="number">333</span>;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>如果要直接为对象的所有属性开发一个校验器可能很快就会让代码结构变得臃肿，使用Proxy则可以将校验器从核心逻辑分离出来自成一体</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createValidator</span>(<span class="params">target, validator</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">        <span class="attr">_validator</span>: validator,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="keyword">let</span> validator = <span class="built_in">this</span>._validator[key];</span><br><span class="line">                <span class="keyword">if</span> (!!validator(value)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Cannot set <span class="subst">$&#123;key&#125;</span> to <span class="subst">$&#123;value&#125;</span>. Invalid.`</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is not a valid property`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personValidators = &#123;  </span><br><span class="line">    <span class="function"><span class="title">name</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">age</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> age === <span class="string">&#x27;number&#x27;</span> &amp;&amp; age &gt; <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> createValidator(<span class="built_in">this</span>, personValidators);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bill = <span class="keyword">new</span> Person(<span class="string">&#x27;Bill&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作都会报错</span></span><br><span class="line">bill.name = <span class="number">0</span>;  </span><br><span class="line">bill.age = <span class="string">&#x27;Bill&#x27;</span>;  </span><br><span class="line">bill.age = <span class="number">15</span>;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过校验器和主逻辑的分离，你可以无限扩展 personValidators 校验器的内容，而不会对相关的类或函数造成直接破坏。更复杂一点，我们还可以使用 Proxy 模拟类型检查，检查函数是否接收了类型和数量都正确的参数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;  </span><br><span class="line">    <span class="attr">pickyMethodOne</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj, str, num</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    <span class="attr">pickyMethodTwo</span>: <span class="function"><span class="keyword">function</span>(<span class="params">num, obj</span>) </span>&#123; <span class="comment">/*... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argTypes = &#123;  </span><br><span class="line">    <span class="attr">pickyMethodOne</span>: [<span class="string">&quot;object&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;number&quot;</span>],</span><br><span class="line">    <span class="attr">pickyMethodTwo</span>: [<span class="string">&quot;number&quot;</span>, <span class="string">&quot;object&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;  </span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, proxy</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = target[key];</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> checkArgs = argChecker(key, args, argTypes[key]);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argChecker</span>(<span class="params">name, args, checkers</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> idx = <span class="number">0</span>; idx &lt; args.length; idx++) &#123;</span><br><span class="line">        <span class="keyword">var</span> arg = args[idx];</span><br><span class="line">        <span class="keyword">var</span> type = checkers[idx];</span><br><span class="line">        <span class="keyword">if</span> (!arg || <span class="keyword">typeof</span> arg !== type) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">`You are incorrectly implementing the signature of <span class="subst">$&#123;name&#125;</span>. Check param <span class="subst">$&#123;idx + <span class="number">1</span>&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objProxy.pickyMethodOne(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;&#x27;</span>);  </span><br><span class="line"><span class="comment">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1</span></span><br><span class="line"><span class="comment">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2</span></span><br><span class="line"><span class="comment">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3</span></span><br><span class="line"></span><br><span class="line">objProxy.pickyMethodTwo(<span class="string">&quot;wopdopadoo&quot;</span>, &#123;&#125;);  </span><br><span class="line"><span class="comment">// &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No warnings logged</span></span><br><span class="line">objProxy.pickyMethodOne(&#123;&#125;, <span class="string">&quot;a little string&quot;</span>, <span class="number">123</span>);  </span><br><span class="line">objProxy.pickyMethodTwo(<span class="number">123</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>访问日志</p>
<blockquote>
<p>对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用Proxy充当中间件的角色，轻而易举实现日志功能</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;  </span><br><span class="line">    <span class="attr">_apiKey</span>: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    <span class="attr">getUsers</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    <span class="attr">getUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    <span class="attr">setUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMethodAsync</span>(<span class="params">timestamp, method</span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;timestamp&#125;</span> - Logging <span class="subst">$&#123;method&#125;</span> request asynchronously.`</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;  </span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, proxy</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = target[key];</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">            logMethodAsync(<span class="keyword">new</span> <span class="built_in">Date</span>(), key);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.getUsers();</span><br></pre></td></tr></table></figure>

<p>预警和拦截</p>
<blockquote>
<p>假设你不想让其他开发者删除 noDelete 属性，还想让调用 oldMethod 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 doNotChange 属性，那么就可以使用 Proxy 来实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dataStore = &#123;  </span><br><span class="line">    <span class="attr">noDelete</span>: <span class="number">1235</span>,</span><br><span class="line">    <span class="attr">oldMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span> &#125;,</span><br><span class="line">    <span class="attr">doNotChange</span>: <span class="string">&quot;tried and true&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NODELETE = [<span class="string">&#x27;noDelete&#x27;</span>];  </span><br><span class="line"><span class="keyword">const</span> NOCHANGE = [<span class="string">&#x27;doNotChange&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> DEPRECATED = [<span class="string">&#x27;oldMethod&#x27;</span>];  </span><br><span class="line"></span><br><span class="line">dataStore = <span class="keyword">new</span> <span class="built_in">Proxy</span>(dataStore, &#123;  </span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (NOCHANGE.includes(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> is immutable.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (NODELETE.includes(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> cannot be deleted.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, key);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEPRECATED.includes(key)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">`Warning! <span class="subst">$&#123;key&#125;</span> is deprecated.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> val = target[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span> ?</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">            &#125; :</span><br><span class="line">            val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// these will throw errors or log warnings, respectively</span></span><br><span class="line">dataStore.doNotChange = <span class="string">&quot;foo&quot;</span>;  </span><br><span class="line"><span class="keyword">delete</span> dataStore.noDelete;  </span><br><span class="line">dataStore.oldMethod();</span><br></pre></td></tr></table></figure>

<p>过滤操作</p>
<blockquote>
<p>某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，就不需要在对新的请求作出响应（非绝对），这个时候就可以使用 Proxy 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;  </span><br><span class="line">    <span class="attr">getGiantFile</span>: <span class="function"><span class="keyword">function</span>(<span class="params">fileId</span>) </span>&#123;<span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;  </span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> id = args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">let</span> isEnroute = checkEnroute(id);</span><br><span class="line">            <span class="keyword">let</span> isDownloading = checkStatus(id);      </span><br><span class="line">            <span class="keyword">let</span> cached = getCached(id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isEnroute || isDownloading) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">                <span class="keyword">return</span> cached;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>中断代理</p>
<blockquote>
<p>Proxy支持随时取消对target的代理，这一操作常用于完全封闭对数据或接口的访问。在下面的示例中，我们使用了Proxy.revocable方法创建了可撤销代理的代理对象：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;proxy,revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo <span class="comment">// 123</span></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure>

<h2 id="Proxy和Object-defineProperty-的区别"><a href="#Proxy和Object-defineProperty-的区别" class="headerlink" title="Proxy和Object.defineProperty()的区别"></a>Proxy和Object.defineProperty()的区别</h2><p>Object.defineProperty() 的问题主要有三个：  </p>
<ul>
<li>不能监听数组的变化</li>
<li>必须遍历对象的每个属性</li>
<li>必须深层遍历嵌套的对象<br>Proxy：  </li>
<li>针对对象：针对整个对象,而不是对象的某个属性</li>
<li>支持数组：不需要对数组的方法进行重载，省去了众多 hack</li>
<li>嵌套支持：get 里面递归调用 Proxy 并返回<blockquote>
<p>优势：Proxy 的第二个参数可以有 13 种拦截方法，比 Object.defineProperty() 要更加丰富,Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。<br>劣势：Proxy 的兼容性不如 Object.defineProperty() (caniuse 的数据表明，QQ 浏览器和百度浏览器并不支持 Proxy，这对国内移动开发来说估计无法接受，但两者都支持 Object.defineProperty()),不能使用 polyfill 来处理兼容性</p>
</blockquote>
<h2 id="12-Reflect"><a href="#12-Reflect" class="headerlink" title="12.Reflect"></a>12.Reflect</h2>Reflect是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的（不能使用new进行调用，所有属性和方法都是静态的）。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(target, thisArgument, argumentsList)</span><br><span class="line"><span class="comment">// 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。</span></span><br><span class="line"><span class="built_in">Reflect</span>.construct(target, argumentsList[, newTarget])</span><br><span class="line"><span class="comment">// 对构造函数进行 new 操作，相当于执行 new target(...args)。</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(target, propertyKey, attributes)</span><br><span class="line"><span class="comment">// 和 Object.defineProperty() 类似。如果设置成功就会返回 true</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(target, propertyKey)</span><br><span class="line"><span class="comment">// 作为函数的delete操作符，相当于执行 delete target[name]。</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(target, propertyKey[, receiver])</span><br><span class="line"><span class="comment">// 获取对象身上某个属性的值，类似于 target[name]。</span></span><br><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(target, propertyKey)</span><br><span class="line"><span class="comment">// 类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 undefined.</span></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(target)</span><br><span class="line"><span class="comment">// 类似于 Object.getPrototypeOf()。</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(target, propertyKey)</span><br><span class="line"><span class="comment">// 判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。</span></span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(target)</span><br><span class="line"><span class="comment">// 类似于 Object.isExtensible().</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(target)</span><br><span class="line"><span class="comment">// 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable影响).</span></span><br><span class="line"><span class="built_in">Reflect</span>.preventExtensions(target)</span><br><span class="line"><span class="comment">// 类似于 Object.preventExtensions()。返回一个Boolean。</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(target, propertyKey, value[, receiver])</span><br><span class="line"><span class="comment">// 将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(target, prototype)</span><br><span class="line"><span class="comment">// 设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回true。</span></span><br></pre></td></tr></table></figure>
<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/tugenhua0707/p/10291909.html">更多</a></li>
</ul>
<h2 id="13-Promise"><a href="#13-Promise" class="headerlink" title="13.Promise"></a>13.Promise</h2><p>在promise这种编程概念出现之前，回调函数是异步编程的主要思想，但是当一个业务依赖另一个业务结果时，就出现了回调嵌套，当回调嵌套越来越多，就形成了回调地狱，代码冗杂，不易读，不易维护，之后便出现了promise的编程概念，直到被ES规范实现成为标准API。</p>
<p>顾名思义，promise就是承诺，这里就是Promise对象对使用者的一个承诺，即当你使用promise去处理一个业务时，它能承诺给你对应的结果，不管是成功还是失败，都是可预见的。且promise实现了链式调用和promise.all等方法，彻底解决了回调地狱的问题，代码层次清晰，更易读，更易维护。</p>
<p>此文不再对Promise做更多详细介绍，具体可参考以下链接：</p>
<ul>
<li>使用 promises —— MDN</li>
<li>Promise —— MDN</li>
<li>Promise — 廖雪峰</li>
<li>JavaScript Promise：去而复返 —— 司徒正美</li>
<li>(上面的原文)JavaScript Promise：简介 —— Web Fundamentals</li>
<li>1 分钟读完《10 分钟学会 JavaScript 的 Async/Await》 —— justjavac</li>
<li>JavaScript Promise 迷你书（中文版）</li>
<li>JavaScript 进阶之路——认识和使用 Promise，重构你的 Js 代码 —— 博客园<br>熟悉掌握Promise后，可自己尝试实现Promise的一些基本功能，以下给出一些思路和待实现功能点，不详细之处可自行实现：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.Promise是一个类，新建时传递一个立即执行的执行器</span></span><br><span class="line"><span class="comment"> * 2.promise中有三种状态，等待（pending），成功（fulfilled），失败（rejected）</span></span><br><span class="line"><span class="comment"> *      pending --&gt; fulfilled;</span></span><br><span class="line"><span class="comment"> *      pending --&gt; rejected;</span></span><br><span class="line"><span class="comment"> *      状态只能由等待变为成功或者等待变为失败，且一旦状态确定就不可更改</span></span><br><span class="line"><span class="comment"> * 3.resolve和reject方法是用来更改状态的，resolve -&gt; fulfilled，reject -&gt; rejected</span></span><br><span class="line"><span class="comment"> * 4.then方法的作用就是判断状态，如果成功就调用resolve，失败就调用reject，then方法是定义在原型对象中的</span></span><br><span class="line"><span class="comment"> * 5.then的回调函数带有参数，成功时表示成功的值，失败时表示失败的原因</span></span><br><span class="line"><span class="comment"> * 6.如果promise内执行的是异步代码时（异步后resolve或reject），如果直接调用then中的回调，导致无法获得执行结果，所以在then时先存储回调，在真正完成（resolve或reject）的时候再调用相应的回调</span></span><br><span class="line"><span class="comment"> * 7.如果promise的then多次调用应该添加多个处理函数的回调，此时需要将上一步存储的处理函数改造成集合</span></span><br><span class="line"><span class="comment"> * 8.then方法的链式调用，如果要链式调用，then方法应该返回一个promise对象</span></span><br><span class="line"><span class="comment"> * 9.错误捕获，执行器函数和then回调中</span></span><br><span class="line"><span class="comment"> * 10.将then方法中的参数改为可选项</span></span><br><span class="line"><span class="comment"> * 11.实现promise.all方法（全部成功才resolve，一个失败就reject）</span></span><br><span class="line"><span class="comment"> * 12.实现promise.resolve，如果接收的参数是promise了直接返回，不是则new一个然后resolve对应的参数</span></span><br><span class="line"><span class="comment"> * 13.finally方法的实现</span></span><br><span class="line"><span class="comment"> * 14.catch方法实现</span></span><br><span class="line"><span class="comment"> * 15.race方法实现，不管成功还是失败，先结束的先resolve或reject</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="14-class类"><a href="#14-class类" class="headerlink" title="14.class类"></a>14.class类</h2><p>MDN中对class的定义是，class 声明创建一个基于原型继承的具有给定名称的新类。</p>
<p>简单点，你就理解为，class定义后，可以new出一个实例来，它其实是一个让JavaScript看上去更像面向对象的语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function和class定义类，都可以new出实例来，即以下方法一和方法二等价</span></span><br><span class="line"><span class="comment">/* 方法一</span></span><br><span class="line"><span class="comment">function Person(name) &#123;</span></span><br><span class="line"><span class="comment">    this.name = name</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Person.prototype.say = function () &#123;</span></span><br><span class="line"><span class="comment">    console.log(`my name is $&#123;this.name&#125;`);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法二</span></span><br><span class="line"><span class="comment">class Person&#123;</span></span><br><span class="line"><span class="comment">    constructor(name) &#123;</span></span><br><span class="line"><span class="comment">        this.name = name</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    say() &#123;</span></span><br><span class="line"><span class="comment">        console.log(`my name is $&#123;this.name&#125;`);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;SeaChan&#x27;</span>)</span><br><span class="line">p.say(); <span class="comment">// 方法一和方法二都打印相同结果：my name is SeaChan</span></span><br></pre></td></tr></table></figure>

<p>class中的静态方法（static）;不使用new就可通过类名调用的方法，如果其中返回实例，就可不用new直接创建一个实例对象，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = Person.create(<span class="string">&#x27;SeaChan&#x27;</span>)</span><br><span class="line">p.say(); <span class="comment">// my name is SeaChan</span></span><br></pre></td></tr></table></figure>

<p>类的继承（extends）；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kids</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);  <span class="comment">// 调用父类的构造函数；</span></span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.say();  <span class="comment">// 调用父类的say方法；</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`hello, I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kid = <span class="keyword">new</span> Kids(<span class="string">&#x27;SeaChan&#x27;</span>, <span class="number">17</span>)</span><br><span class="line">kid.hello()</span><br><span class="line"><span class="comment">// my name is SeaChan</span></span><br><span class="line"><span class="comment">// hello, I am 17 years old!</span></span><br></pre></td></tr></table></figure>

<h2 id="15-Set和Map"><a href="#15-Set和Map" class="headerlink" title="15.Set和Map"></a>15.Set和Map</h2><p>Set和Map是ES6新增的数据类型；</p>
<p>Set和数组很像，它是一系列数据的集合，可以按照插入的顺序迭代它的元素。Set中的元素只会出现一次，即Set中的元素是唯一的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">set.add(<span class="number">1</span>).add(<span class="number">3</span>).add(<span class="number">2</span>).add(<span class="number">4</span>).add(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br><span class="line"><span class="comment">// Set(4) &#123;1, 3, 2, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历set</span></span><br><span class="line">set.forEach(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set.size);  <span class="comment">// 4 获取集合的长度，类似数组的arr.length；</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// false 判断集合中是否含有某一个元素，类似数组的arr.includes()</span></span><br><span class="line"><span class="built_in">console</span>.log(set.delete(<span class="number">2</span>)); <span class="comment">// true 删除集合中的某个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(set);           <span class="comment">// Set(3) &#123;1, 3, 4&#125;</span></span><br><span class="line">set.clear()                 <span class="comment">// 清空集合</span></span><br><span class="line"><span class="built_in">console</span>.log(set);           <span class="comment">// Set(0) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组和Set之间的转换</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line"><span class="built_in">console</span>.log(res)    <span class="comment">// Set(5) &#123;1, 2, 3, 6, 4&#125;; 元素唯一性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(res) <span class="comment">// (5) [1, 2, 3, 6, 4];  Set转数组</span></span><br><span class="line">[...res]        <span class="comment">// (5) [1, 2, 3, 6, 4];  Set转数组</span></span><br></pre></td></tr></table></figure>

<p>Map是一种能根据原始插入顺序（即：可迭代）记录键值对的数据类型。其中任何值（对象或者原始值）都可以作为一个键或者一个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">&#x27;SeaChan&#x27;</span>, <span class="string">&#x27;99&#x27;</span>)</span><br><span class="line">map.set(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;90&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> key1 = &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;</span><br><span class="line">map.set(key1, <span class="string">&#x27;hahahaha&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br><span class="line"><span class="comment">// map.get(&#x27;SeaChan&#x27;)   根据键读取值</span></span><br><span class="line"><span class="comment">// map.has(&#x27;SeaChan&#x27;)   判断是否存在某个键值对</span></span><br><span class="line"><span class="comment">// map.delete(&#x27;Tom&#x27;)    删除某个键值对</span></span><br><span class="line"><span class="comment">// map.clear()          清空map</span></span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="16-Symbol"><a href="#16-Symbol" class="headerlink" title="16.Symbol"></a>16.Symbol</h2><p>Symbol是ES6新增的基本数据类型，每个从Symbol()返回的symbol值都是唯一的，使用它的目的是为对象创建一个唯一属性的标识符，保证对象中的属性不会被修改或者被覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym1 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sym2 === sym3    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol 数据类型具有隐藏性，for···in，object.keys()不能访问</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">key0</span>: <span class="string">&#x27;000&#x27;</span>,</span><br><span class="line">    [sym1]: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    [sym2]: <span class="string">&#x27;456&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> objKey <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(objKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key0  只打印一个key0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));  <span class="comment">// [&quot;key0&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要访问对象中存在的symbol属性，可以使用Object.getOwnPropertySymbols</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj))   <span class="comment">// (2) [Symbol(), Symbol(foo)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了保证多次使用同一个symbol的情况，可以使用全局注册并登记的方法：Symbol.for()</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2);     <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 注意： Symbol.for()接收一个字符串，如果不是字符串会转为字符串，即Symbol.for(&#x27;true&#x27;) === Symbol.for(true)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反之能通过另一个方法获取对象的参数值，Symbol.keyFor()</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1));  <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2));  <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON.stringfy()无法序列化对象中的symbol属性，会被忽略</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj)   <span class="comment">// &quot;&#123;&quot;key0&quot;:&quot;000&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="17-for…of循环"><a href="#17-for…of循环" class="headerlink" title="17.for…of循环"></a>17.for…of循环</h2><p>因为for…in对象遍历存在一些一定的局限性，引入了全新的for…of循环，作为遍历所有数据结构的统一方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">// for (const item of arr) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(item);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr.forEach(item =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(item)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>           <span class="comment">// 可跳出循环，arr.forEach()不可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历Set和Map等实现了iterator接口的数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s3&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s1 s2 s3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;m1&#x27;</span>), <span class="string">&#x27;m1&#x27;</span>)</span><br><span class="line">m.set(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;m2&#x27;</span>), <span class="string">&#x27;m2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [val, key] <span class="keyword">of</span> m) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) Symbol(m1) &quot;m1&quot;</span></span><br><span class="line"><span class="comment">// (2) Symbol(m2) &quot;m2&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让我们试试原始的Object使用for...of会怎样</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错： Uncaught TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure>

<p>以上看到Object通过for…of遍历报错，提示obj不可迭代，说明要满足for…of循环必须满足iterator条件，为了给数据提供这种条件，ES2015提供了iterator接口，实现该接口就是for…of遍历的基础。来看一下数组上的iterator：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> ire = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">ire.next()   <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">ire.next()   <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">ire.next()   <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">ire.next()   <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>可迭代接口实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">store</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">value</span>: _this.store[index],</span><br><span class="line">                    <span class="attr">done</span>: index++ &gt;= _this.store.length</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>迭代器模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**迭代器设计模式*/</span></span><br><span class="line"><span class="comment">// 场景：你我协同开发一个任务清单应用</span></span><br><span class="line"><span class="comment">// A的代码：=============================</span></span><br><span class="line"><span class="comment">/*const todos = &#123;</span></span><br><span class="line"><span class="comment">        life: [&#x27;吃饭&#x27;, &#x27;睡觉&#x27;, &#x27;打豆豆&#x27;],</span></span><br><span class="line"><span class="comment">        learn: [&#x27;语文&#x27;, &#x27;数学&#x27;, &#x27;英语&#x27;]</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =====&gt;  todos中每次添加一个集合，B就要添加一次遍历，且还需要沟通是啥字段</span></span><br><span class="line"><span class="comment">// 修改为迭代器模式</span></span><br><span class="line"><span class="keyword">const</span> todos = &#123;</span><br><span class="line">    <span class="attr">life</span>: [<span class="string">&#x27;吃饭&#x27;</span>, <span class="string">&#x27;睡觉&#x27;</span>, <span class="string">&#x27;打豆豆&#x27;</span>],</span><br><span class="line">    <span class="attr">learn</span>: [<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>],</span><br><span class="line">    <span class="attr">work</span>: [<span class="string">&#x27;编程&#x27;</span>, <span class="string">&#x27;洗衣服&#x27;</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> allData = [...this.life, ...this.learn, ...this.work]</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">value</span>: allData[index],</span><br><span class="line">                    <span class="attr">done</span>: index++ &gt;= allData.length</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// B的代码：=============================</span></span><br><span class="line"><span class="comment">// 要获取所有todo的项目</span></span><br><span class="line"><span class="comment">/*for (const item of todos.life) &#123;</span></span><br><span class="line"><span class="comment">    console.log(item);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for (const item of todos.learn) &#123;</span></span><br><span class="line"><span class="comment">    console.log(item);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A使用迭代器模式后 ======&gt;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> todos) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);  <span class="comment">// 吃饭 睡觉 打豆豆 语文 数学 英语 编程 洗衣服</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-生成器（Generator）"><a href="#18-生成器（Generator）" class="headerlink" title="18.生成器（Generator）"></a>18.生成器（Generator）</h2><p>由生成器函数函数返回，并且满足可迭代接口。</p>
<p>避免异步编程中回调嵌套太深，提供更好的异步编程解决方案。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generator 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;SeaChan&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = fn()</span><br><span class="line"><span class="built_in">console</span>.log(f);   <span class="comment">// 打印一个生成器对象</span></span><br><span class="line"></span><br><span class="line">f.next()</span><br><span class="line"><span class="comment">// SeaChan</span></span><br><span class="line"><span class="comment">// &#123;value: 123, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>完整的生成器配合yield使用，实质效果就是，调用一下生成器对象的next方法，就执行一部分代码，到下一个yield停止，next直到所有的yield执行完后结果变为{value: undefined, done: true}不再改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = fn()</span><br><span class="line">g.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>Generator应用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发号器，执行一次next方法，发号器号码自增1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">numberMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numMaker = numberMaker()</span><br><span class="line"><span class="built_in">console</span>.log(numMaker.next().value);  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(numMaker.next().value);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(numMaker.next().value);  <span class="comment">// 2</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生成器函数实现 iterator 接口</span></span><br><span class="line"><span class="keyword">const</span> todos = &#123;</span><br><span class="line">    <span class="attr">life</span>: [<span class="string">&#x27;吃饭&#x27;</span>, <span class="string">&#x27;睡觉&#x27;</span>, <span class="string">&#x27;打豆豆&#x27;</span>],</span><br><span class="line">    <span class="attr">learn</span>: [<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>],</span><br><span class="line">    <span class="attr">work</span>: [<span class="string">&#x27;编程&#x27;</span>, <span class="string">&#x27;洗衣服&#x27;</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> allData = [...this.life, ...this.learn, ...this.work]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> allData) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> todos) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);      <span class="comment">// 吃饭 睡觉 打豆豆 语文 数学 英语 编程 洗衣服</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-ES2016-新增特性"><a href="#19-ES2016-新增特性" class="headerlink" title="19.ES2016 新增特性"></a>19.ES2016 新增特性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES2016</span></span><br><span class="line"><span class="comment">// Array.prototype.includes()  判断数组是否含有某一个元素</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="string">&#x27;seachan&#x27;</span>, <span class="literal">NaN</span>]</span><br><span class="line">arr.includes(<span class="number">1</span>)          <span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="string">&#x27;seachan&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="literal">NaN</span>)        <span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="number">0</span>)          <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指数运算符 ** ； num1 ** num2 表示num1的num2次幂</span></span><br><span class="line"><span class="comment">// 2**3 ====&gt; 8</span></span><br></pre></td></tr></table></figure>

<h2 id="20-ES2017-新增特性"><a href="#20-ES2017-新增特性" class="headerlink" title="20.ES2017 新增特性"></a>20.ES2017 新增特性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Object.values() 获取对象中值的集合</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj)  <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key,val] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, val);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj))</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 1</span></span><br><span class="line"><span class="comment">// b 2</span></span><br><span class="line"><span class="comment">// Map(2) &#123;&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.getOwnPropertyDescriptors()  方法用来获取一个对象的所有自身属性的描述符</span></span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Sea&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Chan&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p1.fullName)            <span class="comment">// Sea Chan</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Object</span>.assign(&#123;&#125;, p1)</span><br><span class="line">p2.lastName = <span class="string">&#x27;Li&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.fullName)            <span class="comment">// Sea Chan</span></span><br><span class="line"><span class="keyword">let</span> des = <span class="built_in">Object</span>.getOwnPropertyDescriptors(p1)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, des)</span><br><span class="line">p3.lastName = <span class="string">&#x27;Li&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p3.fullName);           <span class="comment">// Sea Li</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String.prototype.padStart()和String.prototype.padEnd()   在字符串前和字符串后添加某个字符知道满足某个长度</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;string&#x27;</span></span><br><span class="line">str.padStart(<span class="number">10</span>, <span class="string">&#x27;+&#x27;</span>)  <span class="comment">// &quot;++++string&quot;</span></span><br><span class="line">str.padEnd(<span class="number">10</span>, <span class="string">&#x27;@&#x27;</span>)    <span class="comment">// &quot;string@@@@&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数参数中添加尾逗号，利于代码管理工具判断修改的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">param1,</span></span></span><br><span class="line"><span class="params"><span class="function">param2,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//***</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Async/Await</span></span><br></pre></td></tr></table></figure>



<p>大前端，冲鸭！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>大前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>ES2015</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的 this 到底是什么</title>
    <url>/2021/06/07/20210607233246/</url>
    <content><![CDATA[<p>文章刚初始化，后续完善内容。。。</p>
<iframe src="../page/index.html" frameborder="0"></iframe>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
